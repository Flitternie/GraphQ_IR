#!/usr/bin/ruby

$version = 70

<<EOF
A simple workqueue system for distributed jobs over many machines.

Run a master:
  q -mode master
Run a worker on every machine you're going to use (change 'localhost' to the hostname of the master)
  q -mode worker -masterHost localhost

To run a job:
  q -add ls /                               # Adds a new job
  q -time 1h -mem 2g -priority 5 -add ls /  # Adds a new job with resource constraints
To print out information about jobs:
  q -list             # Shows all jobs
  q -list running     # Shows running jobs
  q -info J-r5r0yb    # Print out information about a specific job
To manipulate jobs:
  q -kill J-r5r0yb
  q -delete J-r5r0yb
  q -rerun J-r5r0yb
To see the workers:
  q -w

Terminology:
- Client: submits jobs to the master.
- Master: dispatches jobs to the workers.
- Worker: fetches jobs from the master (and inputs if necessary) and runs them.
- Job: a command along with a set of input and output paths.

Notes:
- Assume the master can ssh into each worker without a password.
- Assume that the master and the client share the same file system.
- All time and memory variables are stored using seconds and megabytes, respectively.

When the worker is running on a different machine, you can specify the set of
files that need to be copied to the worker machine and back.  To do this, you
need to create a job.spec file.  Here's an example:

priority: 5
inPaths:
 - file_to_copy_to_worker1
 - file_to_copy_to_worker2
outFiles:
 - full:small_file_to_copy_back
 - append:log_file_to_copy_back_incrementally

If using Amazon EC2, master needs:
  gem install amazon-ec2

TODO:
- Automatically clean up the disk (temporary directories)
- Differentiate machine from worker
EOF

require 'thread'
require 'xmlrpc/server'
require 'xmlrpc/client'
require 'yaml'
require 'pathname'
require File.dirname(Pathname.new($0).realpath) + '/../lib/myutils'

$progName = File.basename($0)
$username = `whoami`.chomp
$hostname = `hostname -f`.chomp
$restartCommand = [$0]+ARGV
$outPathPlaceholder = "_OUTPATH_" # We will substitute occurrences of this in the command with the actual directory in the pool directory

############################################################
# General utilities

def loadYaml(path); f = open(path, 'r'); x = YAML::load(f); f.close; x end
def saveYaml(path, x); f = open(path, 'w'); f.puts YAML::dump(x); f.close end
def newHandle(prefix,n=6); prefix+'-'+(0...n).map { x = rand(36); x += x < 10 ? ?0.ord : ?a.ord-10; x.chr }.join('') end
def encode(x); XMLRPC::Base64.encode(x) end
def decode(x); XMLRPC::Base64.decode(x) end

def renderTable(table, showHeaders, showTabs) # First row is headers
  table = table[1..-1] unless showHeaders
  # Compute maximum width of columns
  width = []
  table.each { |row|
    row.each_with_index { |x,i|
      width[i] = [width[i] || 0, x.size].max
    }
  }
  table.map { |row|
    if showTabs
      row.join("\t")
    else
      row.map_with_index { |x,i| i == row.size-1 ? x : sprintf("%-#{width[i]}s", x) }.join('  ')
    end
  }
end

def ensureNoNulls(x)
  bad = false
  recurse = lambda { |a|
    case a
    when nil then bad = true; ""
    when Array then a.map { |b| recurse.call(b) }
    when Hash then newa = {}; a.each { |k,b| newa[recurse.call(k)] = recurse.call(b) }; newa
    else a
    end
  }
  newx = recurse.call(x)
  puts "Contains nil: #{x.inspect}" if bad
  newx
end

def getVersion(path)
  return nil if not File.exists?(path)
  File.stat(path).mtime.to_i
end
def findFreePath(path)
  raise "Not directory: #{path}" unless File.directory?(path)
  hit = {}
  Dir.entries(path).each { |name| hit[name] = true }
  (0...1000000).each { |i|
    name = "#{i}.exec"
    return path+"/"+name if not hit[name]
  }
  raise "Failed"
end
def relPath(path); path.sub(/^#{File.expand_path('.')}\//, "") end

def truncate(s, n=80)
  n -= 3
  return s if s.size <= n
  s[0...n/2]+'...'+s[s.size-n/2..-1]
end

def ssh(map)
  user = map[:user] || $username
  host = map[:host] or raise "Missing host"
  command = map[:command] or raise "Missing command"
  command !~ /'"/ or raise "Command can't have quotes: #{command}"
  cmd = ['ssh', '-o', 'StrictHostKeyChecking=no', user+'@'+host, "\"bash --login -c '#{command}'\""] # Uggh...double quotes (command can't have any quotes)
  puts cmd.join(' ')
  system(cmd.join(' ')) # Note: need to make a single string out of this
end
def scp(map)
  user = map[:user] || $username
  host = map[:host] or raise "Missing host"
  source = map[:source] or raise "Missing source"
  dest = map[:dest] or raise "Missing dest"
  dir = map[:dir] or raise "Missing direction"
  cmd = ['rsync', '-arzk', '-e', 'ssh -o StrictHostKeyChecking=no', '--exclude=.svn', '--delete']
  if dir == :to
    cmd += [source, user+'@'+host+':'+dest]
  elsif dir == :from
    cmd += [user+'@'+host+':'+source, dest]
  else
    raise "Invalid direction: #{dir} (must be :to or :from)"
  end
  puts cmd.join(' ')
  system(*cmd)
end

class Format
  def self.space(mb) # In megabytes
    return nil unless mb
    gb = (mb / 1024).to_i
    return "#{gb}g" if gb >= 10
    "#{mb}m"
  end
  def self.time(s) # In seconds
    return nil unless s
    m = s / 60; s %= 60
    h = m / 60; m %= 60
    d = h / 24; h %= 24
    y = d / 365; d %= 365
    return "#{y}y#{d}d" if y > 0
    return "#{d}d#{h}h" if d > 0
    return "#{h}h#{m}m" if h > 0
    return "#{m}m#{s}s" if m > 0
    return "#{s}s"
  end
  def self.date(t)
    return nil unless t
    Time.at(t).strftime('%m/%d %H:%M')
  end
  def self.timeSinceDate(t)
    return nil unless t
    "-"+Format.time(Time.now.to_i-t)
  end

  def self.parseSpace(s) # Return megabytes
    return Integer($1) if s =~ /^(\d+)[mM]$/
    return (Float($1)*1024).round if s =~ /^([\d\.]+)[gG]$/
    return Integer(s)
  end
  def self.parseTime(s) # Return seconds
    return $1.to_i if s =~ /^(\d+)s$/
    return $1.to_i*60 if s =~ /^(\d+)m$/
    return $1.to_i*60*60 if s =~ /^(\d+)h$/
    return $1.to_i*60*60*24 if s =~ /^(\d+)d$/
    return Integer(s)
  end
end

def connectToMaster
  puts "Connecting to #{$masterHost}:#{$masterPort}..." if $verbose >= 2
  XMLRPC::Client.new($masterHost, "/", $masterPort, nil, nil, nil, nil, nil, 600)
end

############################################################

# Specification of the job
class JobSpec
  attr_accessor :handle            # Unique id for this job
  attr_accessor :command           # List of arguments to run
  attr_accessor :workingPath       # What directory (absolute path) this job should be run from
  attr_accessor :inVersionPaths    # [version of the file (e.g., the time), absolute path]
  attr_accessor :outPath           # Where output files are written
  attr_accessor :outModePaths      # [mode (full, final, append) of how to transmit back, absolute path]
  attr_accessor :limitTime         # Limit on the amount of time the job can take (seconds)
  attr_accessor :limitMem          # Limit on the amount of memory the job can use (MB)
  attr_accessor :limitMemGrace     # Kill job if exceeds limitMem * limitMemGrace
  attr_accessor :limitDisk         # Limit on the amount of disk space (MB)
  attr_accessor :nice              # Whether to nice the process
  attr_accessor :priority          # Number between 0 and 20; lower is higher priority (used by master to determine which jobs are run first)
  attr_accessor :tags              # List of strings (used to select/group jobs)
  attr_accessor :creationDate      # When this job was created
  attr_accessor :doneHook          # Command to run when the job finishes successfully
  attr_accessor :failedHook        # Command to run if the job fails
  attr_accessor :freshOutPath      # Delete output path if it already exists in scratch directory
  attr_accessor :workerHandle      # Must run this job on this worker handle
  attr_accessor :shareWorkingPath  # Whether job is to be run in the shared directory

  def initialize
    @inVersionPaths = []
    @outModePaths = []
    @limitTime = Format.parseTime('48h')
    @limitMem = Format.parseSpace('1.5g')
    @limitMemGrace = 1
    @limitDisk = Format.parseSpace('10g')
    @nice = 0
    @priority = 5
    @tags = []
    @creationDate = Time.now.to_i
    @freshOutPath = false
  end

  def outName; outPath && File.basename(outPath) end

  def summary; "#{@handle}: [#{outName}] #{truncate(@command.join(' '))}" end

  def toMap
    map = {}
    map['handle']             = @handle
    map['command']            = @command
    map['workingPath']        = @workingPath
    map['inVersionPaths']     = @inVersionPaths
    map['outPath']            = @outPath if @outPath
    map['outModePaths']       = @outModePaths
    map['limitMem']           = @limitMem
    map['limitMemGrace']      = @limitMemGrace
    map['limitTime']          = @limitTime
    map['limitDisk']          = @limitDisk
    map['priority']           = @priority
    map['nice']               = @nice
    map['tags']               = @tags
    map['creationDate']       = @creationDate
    map['doneHook']           = @doneHook if @doneHook
    map['failedHook']         = @failedHook if @failedHook
    map['freshOutPath']       = @freshOutPath if @freshOutPath
    map['workerHandle']       = @workerHandle if @workerHandle
    map['shareWorkingPath']   = @shareWorkingPath if @shareWorkingPath
    map
  end
  def fromMap(map)
    @handle            = map['handle']           || @handle
    @command           = map['command']          || @command
    @workingPath       = map['workingPath']      || @workingPath
    @inVersionPaths    = map['inVersionPaths']   || @inVersionPaths
    @outPath           = map['outPath']          || @outPath
    @outModePaths      = map['outModePaths']     || @outModePaths
    @limitMem          = map['limitMem']         || @limitMem
    @limitMemGrace     = map['limitMemGrace']    || @limitMemGrace
    @limitTime         = map['limitTime']        || @limitTime
    @limitDisk         = map['limitDisk']        || @limitDisk
    @nice              = map['nice']             || @nice
    @priority          = map['priority']         || @priority
    @tags              = map['tags']             || @tags
    @creationDate      = map['creationDate']     || @creationDate
    @doneHook          = map['doneHook']         || @doneHook
    @failedHook        = map['failedHook']       || @failedHook
    @freshOutPath      = map['freshOutPath']     || @freshOutPath
    @workerHandle      = map['workerHandle']     || @workerHandle
    @shareWorkingPath  = map['shareWorkingPath'] || @shareWorkingPath

    @limitTime = Format.parseTime(@limitTime) if @limitTime
    @limitMem = Format.parseSpace(@limitMem) if @limitMem
    @limitDisk = Format.parseSpace(@limitDisk) if @limitDisk

    # Convenient ways to update the above fields
    if map['inPaths'] # Attach the most recent version of these
      map['inPaths'].each { |path| addInPath(path) }
    end
    outPoolPath = map['outPoolPath']
    if outPoolPath
      outPoolPath = File.expand_path(outPoolPath)
      @outPath = findFreePath(outPoolPath)
      puts @outPath
      Dir.mkdir(@outPath) unless $pretend
      if map['outFiles']
        @outModePaths += map['outFiles'].map { |s| # <mode>:<file> 
          s =~ /^(\w+):(.+)$/
          [$1, @outPath+"/"+$2]
        }
      end
      @freshOutPath = true
    end

    @doneHook = @doneHook.gsub($outPathPlaceholder, @outPath) if @doneHook && @outPath
    @failedHook = @failedHook.gsub($outPathPlaceholder, @outPath) if @failedHook && @outPath

    self
  end
  def updateVersionPaths
    @inVersionPaths.each { |versionPath| versionPath[0] = getVersion(versionPath[1]) }
  end
  def command=(command)
    if @outPath
      @command = command.map { |x| x.gsub($outPathPlaceholder, @outPath) }
    else
      @command = command
    end
  end

  def addInPath(path)
    path = File.expand_path(path)
    version = getVersion(path)
    raise "Not found: #{path}" unless version
    @inVersionPaths << [version, path]
  end
end

class JobState
  attr_accessor :status, :reason # One of {assigned, init, running, done, failed}
  attr_accessor :realTime, :userTime, :mem, :maxMem, :disk, :maxDisk # What's used by the job
  attr_accessor :workerHandle # Where this job was run
  attr_accessor :startDate # When this job started
  attr_accessor :exitCode

  def initialize
    @status = 'assigned'
    @reason = ""
    @realTime = -1
    @userTime = -1
    @mem = -1
    @maxMem = -1
    @disk = -1
    @maxDisk = -1
    @exitCode = ''
  end

  def toMap
    map = {}
    map['status']       = @status
    map['reason']       = @reason
    map['realTime']     = @realTime
    map['userTime']     = @userTime
    map['mem']          = @mem
    map['maxMem']       = @maxMem
    map['disk']         = @disk
    map['maxDisk']      = @maxDisk
    map['workerHandle'] = @workerHandle
    map['startDate']    = @startDate
    map['exitCode']     = @exitCode
    map
  end
  def fromMap(map)
    @status       = map['status']       || @status
    @reason       = map['reason']       || @reason
    @realTime     = map['realTime']     || @realTime
    @userTime     = map['userTime']     || @userTime
    @mem          = map['mem']          || @mem
    @maxMem       = map['maxMem']       || @maxMem
    @disk         = map['disk']         || @disk
    @maxDisk      = map['maxDisk']      || @maxDisk
    @workerHandle = map['workerHandle'] || @workerHandle
    @startDate    = map['startDate']    || @startDate
    @exitCode     = map['exitCode']     || @exitCode
    self
  end
end

class Job
  attr_accessor :spec, :state
  def status; @state ? @state.status : 'ready' end
  def toMap
    map = {}
    map['spec'] = @spec.toMap if @spec
    map['state'] = @state.toMap if @state
    map
  end
  def fromMap(map)
    @spec  = JobSpec.new.fromMap(map['spec']) if map['spec']
    @state = JobState.new.fromMap(map['state']) if map['state']
    self
  end
end

class WorkerState
  attr_accessor :handle, :hostname, :version, :status
  attr_accessor :lifetime # Amount of time of idleness after which we kill a worker
  attr_accessor :numCPUs, :cpuSpeed, :freeMem, :freeDisk, :procSummary, :currJobHandle
  attr_accessor :lastPingDate, :lastJobDate, :pendingAction # Used by master

  def available?; @handle != nil end # Handle set when worker updates state

  def initialize
    @lifetime = Format.parseTime('1h')
    @lastPingDate = Time.new.to_i
    @lastJobDate = Time.new.to_i
  end

  def idleTime; Time.now.to_i - @lastJobDate end
  def tooIdle; idleTime > @lifetime end

  def toMap
    map = {}
    map['handle'] = @handle
    map['hostname'] = @hostname
    map['version'] = @version
    map['status'] = @status
    map['lifetime'] = @lifetime
    map['numCPUs'] = @numCPUs
    map['cpuSpeed'] = @cpuSpeed
    map['freeMem'] = @freeMem
    map['freeDisk'] = @freeDisk
    map['procSummary'] = @procSummary
    map['currJobHandle'] = @currJobHandle if @currJobHandle
    map
  end
  def fromMap(map)
    @handle        = map['handle'] || @handle
    @hostname      = map['hostname'] || @hostname
    @version       = map['version']  || @version
    @status        = map['status']   || @status
    @lifetime      = map['lifetime'] || @lifetime
    @numCPUs       = map['numCPUs']  || @numCPUs
    @cpuSpeed      = map['cpuSpeed'] || @cpuSpeed
    @freeMem       = map['freeMem']  || @freeMem
    @freeDisk      = map['freeDisk'] || @freeDisk
    @procSummary   = map['procSummary'] || @procSummary
    @currJobHandle = map['currJobHandle']

    # Used by master
    @lastPingDate  = Time.new.to_i
    @lastJobDate   = Time.new.to_i if @currJobHandle
    self
  end
end

############################################################

class EC2Inst
  attr_accessor :id, :privateIp, :publicIp, :status
end

class EC2
  def initialize(map)
    require 'AWS'
    accessKeyId = map['accessKeyId'] or raise 'Missing accessKeyId'
    secretAccessKey = map['secretAccessKey'] or raise 'Missing secretAccessKey'
    @imageId = map['imageId']
    @availabilityZone = map['availabilityZone']
    @instanceType = map['instanceType']
    @tag = map['tag']

    @base = AWS::EC2::Base.new(:access_key_id => accessKeyId, :secret_access_key => secretAccessKey)

    # Create the security group
    begin
      result = @base.describe_security_groups(:group_name => @tag)
    rescue AWS::InvalidGroupNotFound
      puts "Creating new security group #{@tag}"
      result = @base.create_security_group(:group_name => @tag, :group_description => @tag)
      result = @base.authorize_security_group_ingress(:group_name => @tag, :ip_protocol => 'tcp', :from_port => 22, :to_port => 22) # Doesn't work
    end
  end

  # Returns the instance id
  def newInstances(n, availabilityZone, instanceType, imageId)
    map = {}
    map[:image_id] = imageId || @imageId
    map[:min_count] = n
    map[:max_count] = n
    map[:availability_zone] = availabilityZone || @availabilityZone
    map[:instance_type] = instanceType || @instanceType
    map[:security_group] = @tag
    rinfo = @base.run_instances(map)
    instances = getInstancesOfReservation(rinfo)
    puts "Created #{n} new instances #{instances.map{|inst| inst.id}.join(' ')}"
    instances
  end

  def terminateInstances(ids)
    # Careful!
    puts "Terminating instances #{ids.join(' ')}"
    @base.terminate_instances(:instance_id => ids)
  end

  def getInstancesOfReservation(rinfo)
    return [] unless rinfo['groupSet']['item'] == [{'groupId' => @tag}] # Only pay attention to our group
    rinfo['instancesSet']['item'].map { |info|
      #puts info.inspect
      inst = EC2Inst.new
      inst.id = info['instanceId']
      inst.privateIp = info['privateIpAddress']
      inst.publicIp = info['ipAddress']
      inst.status = info['instanceState']['name']
      inst
    }
  end

  def getInstances
    info = @base.describe_instances
    #puts YAML::dump(info)
    #puts info.inspect
    info['reservationSet']['item'].map { |rinfo|
      getInstancesOfReservation(rinfo)
    }.flatten
  end
end

class Master
  # Return response
  def performSafely(&block)
    # Need to synchronize; otherwise two requests to the same server causes problems
    begin
      @mutex.lock
      result = block.call
      @mutex.unlock
      ensureNoNulls(result)
    rescue Exception => e
      @mutex.unlock if @mutex.locked?
      puts "EXCEPTION: #{e.message}\n#{e.backtrace.join("\n")}"
      @server.shutdown # This is really bad - we just get out of here (master will be restarted)
      saveState # At least try to save things before we die (hopefully not infinite loop)
    end
  end

  def initialize(args)
    puts "===== master v#{$version} (port #{$masterPort})"
    @mutex = Mutex.new

    @statePath, @confPath, netInterface, = extractArgs(:args => args, :spec => [
      ['state', String, ENV['HOME']+"/.#{$progName}.state"],
      ['conf', String, 'master.conf'],
      ['netInterface', String, '*'],
    nil])

    if File.exists?(@confPath)
      puts "Loading #{@confPath}"
      map = loadYaml(@confPath)
      if map['ec2']
        puts "EC2 enabled"
        @ec2 = EC2.new(map['ec2'])
      end
    end

    @workers = {} # handle -> worker
    @jobs = {} # handle -> job
    loadState

    @server = XMLRPC::Server.new($masterPort, netInterface, 1000)

    # Client commands
    @server.add_handler('AddJob') { |jobSpecMap| performSafely { addJob(jobSpecMap) } }
    @server.add_handler('OperateOnJobs') { |op,spec| performSafely { operateOnJobs(op, spec) } }
    @server.add_handler('SaveState') { performSafely { saveState } }
    @server.add_handler('GetWorkerState') { performSafely { getWorkerState } }
    @server.add_handler('RunWorkers') { |workerHandles| performSafely { runWorkers(workerHandles) } }
    @server.add_handler('StartWorkers') { |n,availabilityZone,instanceType,imageId| performSafely { startWorkers(n,availabilityZone,instanceType,imageId) } }
    @server.add_handler('TermWorkers') { |workerHandles| performSafely { termWorkers(workerHandles) } }
    @server.add_handler('ResetWorkers') { |workerHandles| performSafely { resetWorkers(workerHandles) } }
    @server.add_handler('ClearWorkers') { performSafely { clearWorkers } }
    @server.add_handler('ShutdownMaster') { performSafely { shutdownMaster } }

    # Worker commands
    @server.add_handler('WorkerGetJob') { |workerHandle| performSafely { getJob(workerHandle) } }
    @server.add_handler('WorkerFetchPaths') { |workerHandle,inPaths,outBasePath| fetchPaths(workerHandle, inPaths, outBasePath) }
    @server.add_handler("WorkerSetState") { |workerHandle,state| performSafely { setWorkerState(workerHandle, state) } }

    @server.set_default_handler { |name, *args| raise XMLRPC::FaultException.new(-99, "Method '#{name}' missing or wrong number of parameters!") }
    @server.serve
  end

  def addJob(map)
    jobSpec = JobSpec.new
    jobSpec.fromMap(map)
    handle = jobSpec.handle
    return failedResponse("Job handle #{handle} alrady exists") if @jobs[jobSpec.handle]
    job = Job.new
    job.spec = jobSpec
    @jobs[handle] = job
    #saveState  # In case something bad happens... (too expensive)
    successResponse("Job #{handle} added successfully")
  end

  def matches(job, spec)
    return true if spec == 'all'
    key, spec = $1, $2 if spec =~ /^(\w+):(.+)$/
    return true if (key == nil || key == 'status')  && spec == job.status;               return false if key == 'status'
    return true if (key == nil || key == 'handle')  && spec == job.spec.handle;          return false if key == 'handle'
    return true if (key == nil || key == 'outPath') && job.spec.outPath =~ /\/#{spec}$/; return false if key == 'outPath'
    return true if (key == nil || key == 'tag')     && job.spec.tags.index(spec);        return false if key == 'tag'
    return true if (key == nil || key == 'cmd')     && job.spec.command.index(spec);     return false if key == 'cmd'
    false
  end

  def workerSpec(job)
    state = job.state or return ""
    handle = state.workerHandle or return ""
    worker = @workers[handle] or return handle
    "#{handle} #{worker.hostname}"
  end

  # spec (e.g. ["A,B", "C,D"]) takes a disjunction over the elements of the
  # array and a conjunction over the comma-separated items of those elements.
  def operateOnJobs(op, spec)
    matchedJobs = @jobs.values.select { |job|
      spec.any? { |clause| clause.split(/,/).all? { |term| matches(job, term) } }
    }
    case op
    when 'list'
      response = {'success' => true}
      response['output'] = [['handle', 'worker', 'status', 'exitcode', 'time', 'mem', 'disk', 'outName', 'command']] + matchedJobs.map { |job|
        [job.spec.handle,
         workerSpec(job),
         job.status,
         job.state ? job.state.exitCode : '',
         job.state ? Format.time(job.state.realTime) : '',
         job.state ? Format.space(job.state.maxMem) : '',
         job.state ? Format.space(job.state.maxDisk) : '',
         job.spec.outName ? job.spec.outName : '',
         truncate(job.spec.command.join(' '))]
      }
      ensureNoNulls(response)
    when 'info'
      response = {'success' => true}
      response['output'] = matchedJobs.map { |job| job.toMap }
      ensureNoNulls(response)
    when 'delete'
      selectedJobs = matchedJobs # dangerous
      #selectedJobs = matchedJobs.select { |job| job.status != 'running' }
      selectedJobs.each { |job| @jobs.delete(job.spec.handle) }
      successResponse("Deleted #{selectedJobs.size}/#{matchedJobs.size} jobs")
    when 'kill'
      selectedJobs = matchedJobs.select { |job| job.status == 'running' }
      selectedJobs.each { |job|
        worker = @workers[job.state.workerHandle]
        if worker && worker.currJobHandle == job.spec.handle
          worker.pendingAction = 'kill'
        else
          job.state.status = 'failed'
          job.state.reason = "Worker #{job.state.workerHandle} doesn't exist or not working on job, so marking job as failed"
        end
      }
      successResponse("Requested workers to kill #{selectedJobs.size}/#{matchedJobs.size} jobs")
    when 'rerun'
      selectedJobs = matchedJobs.select { |job| job.status != 'running' && job.status != 'ready' }
      selectedJobs.each { |job| job.state = nil }
      successResponse("Marked #{selectedJobs.size}/#{matchedJobs.size} jobs to rerun")
    else
      failedResponse("Unknown operation: #{op}")
    end
  end

  def loadState
    return unless File.exists?(@statePath)
    state = loadYaml(@statePath)
    if state['jobs']
      state['jobs'].each { |map|
        job = Job.new.fromMap(map)
        @jobs[job.spec.handle] = job
      }
      puts "Loaded #{@jobs.size} jobs from #{@statePath}"
    end
  end

  def saveState
    state = {}
    state['jobs'] = @jobs.values.map { |job| job.toMap }
    saveYaml(@statePath, state)
    successResponse("Saved #{@jobs.size} jobs to state")
  end

  def getWorkerState
    response = {}
    response['success'] = true
    response['output'] = [['handle', 'hostname', 'version', 'status', 'pendingAction', 'numCPUs', 'cpuSpeed', 'freeMem', 'freeDisk', 'procSummary', 'ping', 'job']] + @workers.keys.sort.map { |workerHandle|
      worker = @workers[workerHandle]
      l = [worker.handle, worker.hostname, worker.version, worker.status, worker.pendingAction || "",
           worker.numCPUs, worker.cpuSpeed,
           Format.space(worker.freeMem), Format.space(worker.freeDisk), worker.procSummary]
      l << Format.timeSinceDate(worker.lastPingDate)
      if worker.currJobHandle
        job = @jobs[worker.currJobHandle]
        l << (job ? job.spec.summary : '(invalid)')
      end
      l
    }

    # Print out EC2 instances without an associated worker
    if @ec2
      response['output'] += @ec2.getInstances.map { |inst|
        next if @workers[inst.id] # Already accounted for
        next if inst.status == 'terminated'
        [inst.id, inst.privateIp || '-', '-', "float:#{inst.status}"]
      }.compact
    end

    response
  end

  def runWorkers(workerHandles)
    handles = []
    go = lambda { |handle,ip|
      puts "Running worker #{handle} on #{ip}"
      if not ssh(:host => ip, :command => "#{$progName} -mode worker -handle #{handle} -masterHost #{$hostname} >& #{handle}.log &")
        puts 'ssh command failed'
      else
        handles << handle
      end
    }
    workerHandles.each { |workerHandle|
      if workerHandle == 'floating'
        return failedResponse("EC2 not enabled") unless @ec2
        # Start the worker process on any worker machine that's floating
        @ec2.getInstances.each { |inst|
          next if @workers[inst.id] # Already accounted for
          next unless inst.status == 'running'
          go.call(inst.id, inst.privateIp)
        }
      elsif workerHandle =~ /^dup(\d+)$/ # Make sure each machine has a tagged version running (somewhat hacky)
        tag = $1
        puts "Starting a copy (tag=#{tag}) for each worker..."
        @workers.keys.each { |baseWorkerHandle|
          next if baseWorkerHandle =~ /^(.+)-\d+$/
          workerHandle = "#{baseWorkerHandle}-#{tag}"
          next if @workers[workerHandle] # Already started
          baseWorker = @workers[baseWorkerHandle]
          go.call(workerHandle, baseWorker.hostname) # Same host name
        }
      elsif workerHandle =~ /^(.+)-\d+/
        # Or start another worker on an existing machine (for workerHandle <existingHandle>-<number>)
        next if @workers[workerHandle] # Already started
        baseWorkerHandle = $1
        baseWorker = @workers[baseWorkerHandle]
        next unless baseWorker
        go.call(workerHandle, baseWorker.hostname) # Same host name
      end
    }
    successResponse("Run on #{handles.size} workers: #{handles.join(' ')}")
  end

  def startWorkers(n, availabilityZone, instanceType, imageId)
    availabilityZone = nil if availabilityZone == ""
    instanceType = nil if instanceType == ""
    imageId = nil if imageId == ""
    return failedResponse('EC2 not setup') unless @ec2
    begin
      instances = @ec2.newInstances(n, availabilityZone, instanceType, imageId)
      return failedResponse('Unable to create instance') unless instances
    rescue Exception => e
      return failedResponse("Exception: #{e}")
    end
    successResponse("Successfully created #{instances.size} workers: #{instances.map{|inst| inst.id}.join(' ')}")
  end
  def termWorkers(workerHandles)
    return failedResponse('EC2 not setup') unless @ec2
    begin
      @ec2.terminateInstances(workerHandles)
    rescue Exception => e
      return failedResponse("Exception: #{e}")
    end
    workerHandles.each { |workerHandle| @workers.delete(workerHandle) }
    successResponse("#{workerHandles.size} workers terminated")
  end
  def resetWorkers(workerHandles)
    workerHandles = workerHandles.map { |workerHandle|
      worker = @workers[workerHandle]
      next unless worker
      worker.pendingAction = 'clear'
    }.compact
    successResponse("#{workerHandles.size} workers to be cleared")
  end
  def clearWorkers
    @workers = {}
    successResponse("Removed all workers, waiting for them to contact again")
  end

  def shutdownMaster
    puts "Saving state and shutting down master..."
    saveState
    @server.shutdown
    successResponse("Server is shutting down")
    #puts "Waiting..."
    #sleep 10 # Should be a bit larger than the worker sleep interval so the worker doesn't get stuck in a call
    #exec(*$restartCommand)
  end

  def getWorker(workerHandle)
    worker = @workers[workerHandle] ||= WorkerState.new
    worker
  end

  def getJob(workerHandle)
    worker = getWorker(workerHandle)

    # Find a suitable job
    #puts "Getting job for worker #{worker.handle}" if $verbose >= 3
    if worker.available?
      bestJob = nil
      @jobs.values.each { |job|
        #puts "CONSIDER #{job.status} #{worker.freeMem}"
        next unless job.status == 'ready'
        next unless job.spec.limitMem <= worker.freeMem # Memory requirements
        next if job.spec.workerHandle && job.spec.workerHandle != workerHandle # Can only run it on this machine
        if bestJob == nil ||
           job.spec.priority < bestJob.spec.priority ||
           (job.spec.priority == bestJob.spec.priority && job.spec.creationDate < bestJob.spec.creationDate)
          bestJob = job
        end
      }
      #puts "GOT #{bestJob}"
      if bestJob
        bestJob.spec.updateVersionPaths
        bestJob.state = JobState.new # Mark as running
        bestJob.state.workerHandle = worker.handle
        response = {'success'=>true}
        response['jobSpec'] = bestJob.spec.toMap
        response
      else
        successResponse('No job available')
      end
    else
      successResponse('Worker is not available')
    end
  end

  def fetchPaths(workerHandle, inPaths, outBasePath)
    worker = getWorker(workerHandle)
    inPaths.each { |inPath|
      if not scp(:dir => :to, :host => worker.hostname, :source => inPath, :dest => "#{outBasePath}#{File.dirname(inPath)}")
        return failedResponse("Unable to copy")
      end
    }
    successResponse("#{inPaths.size} paths copied successfully")
  end

  def setWorkerState(workerHandle, map)
    puts "setWorkerState: #{workerHandle}" if $verbose >= 2
    #puts map.inspect
    worker = getWorker(workerHandle)
    worker.fromMap(map['workerState']) if map['workerState']

    if map['jobState']
      jobHandle = map['jobHandle']
      job = @jobs[jobHandle]
      if not job
        puts "Got unknown job #{jobHandle} from worker #{worker.handle}"
      else
        job.state = JobState.new.fromMap(map['jobState'])
        if job.status == 'done' && job.spec.doneHook
          puts "Executing done hook: #{job.spec.doneHook}"
          puts "Executing done hook failed" unless system(job.spec.doneHook)
        end
        if job.status == 'failed' && job.spec.failedHook
          puts "Executing failed hook: #{job.spec.failedHook}"
          puts "Executing failed hook failed" unless system(job.spec.failedHook)
        end
      end
    end

    # Update file contents
    if map['outPathContents']
      map['outPathContents'].each { |path,offsetContents|
        offset, contents = offsetContents
        if offset == 'remote'
          puts "Getting #{path} from #{worker.hostname}" if $verbose >= 1
          scp(:dir => :from, :host => worker.hostname, :source => contents, :dest => path)
        else
          contents = decode(contents)
          puts "Got #{path}:#{offset} (#{contents.size} bytes: #{contents[0...10].inspect})" if $verbose >= 1
          out = open(path, offset > 0 && File.exists?(path) ? 'r+' : 'w')
          out.seek(offset)
          out.write(contents)
          out.close
        end
      }
    end
    
    # Send the command (e.g., to kill the job) if there is one or update current version
    response = successResponse('Acknowledged')
    if worker.pendingAction
      puts "COMMAND TO WORKER #{worker.handle}: #{worker.pendingAction}"
      response['action'] = worker.pendingAction
      worker.pendingAction = nil
    else
      if worker.version < $version && (not worker.currJobHandle)
        puts "COMMAND TO WORKER #{worker.handle}: update from version #{worker.version} to #{$version}"
        response['action'] = 'update'
        response['contents'] = encode(File.read($0))
      end
    end

    # Terminate worker machine if too idle
    if allTooIdle(worker)
      puts "Worker #{worker.handle} was idle for #{Format.time(worker.idleTime)} > #{Format.time(worker.lifetime)}, terminating it"
      termWorkers([worker.handle]) # This is a bit scary (need to verify handle)
    end

    #saveState  # In case something bad happens... (too expensive)
    response
  end

  def allTooIdle(worker)
    return false if worker.handle =~ /^.+-\d+$/
    @workers.values.each { |w| # For each derived worker...
      next unless w.handle =~ /^#{worker.handle}/
      return false if not w.tooIdle
    }
    true
  end

  # Every response is one of these two
  def successResponse(message)
    response = {}
    response['success'] = true
    response['message'] = message
    response
  end
  def failedResponse(message)
    response = {}
    response['success'] = false
    response['message'] = message
    response
  end
end

############################################################

class Worker
  def initialize(args)
    @handle, @sleepInterval, @basePath, = extractArgs(:args => args, :spec => [
      ['handle', String],
      ['sleepInterval', Fixnum, 5],
      ['basePath', String, 'scratch'],
    nil])

    # Make sure we're not running another instance of this worker
    commands = `ps --no-headers ax -o command`.split(/\n/).select { |cmd| cmd =~ /\-handle #{@handle} / }
    if commands.size > 1
      puts "Worker with handle #{@handle} already running:"
      commands.each { |cmd| puts cmd }
      exit 1
    end

    @state = WorkerState.new
    @state.version = $version
    @state.status = 'idle'
    @state.handle = @handle ? @handle : newHandle($hostname.split(/\./)[0], 2)
    puts "===== worker v#{$version} #{@state.handle}, basePath = #{@basePath}"
    puts $restartCommand.join(' ')
    system('mkdir', '-p', @basePath)

    @sendStateMutex = Mutex.new
    @mutex = Mutex.new
    @server = connectToMaster

    startMonitorThread
    runJobsLoop
  end

  def makeCall(*args)
    ensureNoNulls(args)
    puts "call: #{args[0]}" if $verbose >= 2
    response = nil
    @mutex.synchronize { response = @server.call(*args) }
    puts response['message'] if response['message'] && $verbose >= 2 && $verbose >= 2
    response
  end

  def killCurrentJob(message)
    puts "KILL #{@jobPid}: #{message}"
    @job.state.reason = message
    begin
      # Should only need to do this to top-level pid, but just in case...
      getAllDescendantPids(@jobPid).each { |pid| Process.kill('TERM', pid) }
    rescue Exception => e
      puts "Failed to kill: #{e.message}"
    end
  end

  def getAllDescendantPids(rootPid)
    childrenMap = {}
    Dir["/proc/[0-9]*"].each { |dir|
      dir =~ /(\d+)/
      pid = Integer($1)
      next unless File.exists?("#{dir}/status")
      ppid = Integer(readConfig("#{dir}/status", 'PPid'))
      #puts "#{pid} #{ppid}"
      a = childrenMap[ppid] = childrenMap[ppid] || []
      a << pid
    }
    def recurse(childrenMap, descendants, pid)
      descendants << pid
      (childrenMap[pid] || []).each { |cpid|
        recurse(childrenMap, descendants, cpid)
      }
      descendants
    end
    recurse(childrenMap, [], rootPid)
  end

  def readlinesEasy(path)
    File.exists?(path) ? IO.readlines(path) : []
  end

  def readConfig(path, key); getConfig(readlinesEasy(path), key) end
  def getConfig(lines, key)
    lines.each { |line| return $1 if line =~ /^\s*#{key}\s*:\s*(.+)$/ }
    nil
  end
  def freeMem
    free = Integer(readConfig('/proc/meminfo', 'MemFree').split[0])
    cached = Integer(readConfig('/proc/meminfo', 'Cached').split[0])
    buffers = Integer(readConfig('/proc/meminfo', 'Buffers').split[0])
    (free+cached+buffers)/1000
  end

  def getProcSummary
    lines = `ps --no-headers ax -o %cpu,%mem,user,comm`.split(/\n/)
    lines.map { |line|
      cpu, mem, user, command = line.trim.split(/\s+/, 4)
      cpu = Float(cpu)
      mem = Float(mem)
      #puts line
      next unless cpu > 50
      "#{cpu.round},#{mem.round},#{user}[#{command}]"
    }.compact.join(' ')
  end

  def extractWorkerState
    @state.hostname = $hostname
    @state.numCPUs = Integer(readConfig('/proc/cpuinfo', 'cpu cores'))
    @state.cpuSpeed = Float(readConfig('/proc/cpuinfo', 'cpu MHz')).round
    @state.freeMem = freeMem
    @state.freeDisk = Integer(`df #{@basePath} | tail -1`.split[3])/1000
    @state.procSummary = getProcSummary
  end

  def extractJobState
    return unless @job
    state = @job.state
    if @jobPid
      # Reference on /proc/<pid>/stat: http://brokestream.com/procstat.html
      pids = getAllDescendantPids(@jobPid)
      state.mem = pids.map { |pid| Integer((readConfig("/proc/#{pid}/status", 'VmRSS') || "0").split[0]) }.sum / 1000
      state.userTime = readlinesEasy("/proc/#{@jobPid}/stat")[0] =~ /^(\d+) \([^\)]+\) (.*)$/ ? $2.split[11].to_i : -1
    end
    outPath = @basePath+@job.spec.outPath if @job.spec.outPath
    state.disk = `du -sm #{outPath}`.split[0].to_i if outPath && File.exists?(outPath)
    state.realTime = Time.now.to_i - state.startDate
    state.maxMem = [state.maxMem, state.mem].max
    state.maxDisk = [state.maxDisk, state.disk].max
  end

  def getOutPathContents(isLast)
    contents = {}
    newSentState = @sentState.clone

    maxBytes = 16384 # Transmit this much at a time at most

    # Send files
    @job.spec.outModePaths.each { |mode,pathPattern|
      Dir[@basePath+pathPattern].each { |actualPath|
        path = actualPath[@basePath.size..-1]
        newmtime = File.stat(actualPath).mtime
        offset, mtime = @sentState[path]
        offset ||= 0
        offset = 0 if mode != 'append' # mode is either append or full
        next if mtime == newmtime # No changes, don't resend file
        
        # Read information
        f = open(actualPath)
        f.seek(offset)
        s = f.read(maxBytes) || ""
        newoffset = offset + s.size
        f.close

        size = File.size(actualPath)
        if newoffset + 10*1024*1024 < size || (isLast && newoffset < size) # Fall behind by 10MB or at all if the last one
          puts "Falling behind by #{size-newoffset} bytes, resorting to remote copy"
          contents[path] = ['remote', File.expand_path(actualPath)] # Just tell master to get the file directly
          newSentState[path] = [size, newmtime] # All should be recovered (the master might get even more)
        else
          newmtime = mtime if newoffset < size # Can't declare that we're done
          contents[path] = [offset, encode(s)]
          newSentState[path] = [newoffset, newmtime]
        end
      }
    }
    [contents, newSentState]
  end

  def enforceLimits
    return unless @job
    spec, state = @job.spec, @job.state
    if spec.limitTime && state.realTime && state.realTime > spec.limitTime
      killCurrentJob("Current time usage #{Format.time(state.realTime)} exceeds limit #{Format.time(spec.limitTime)}")
    end
    if spec.limitMem && state.mem && state.mem > spec.limitMem * spec.limitMemGrace
      killCurrentJob("Current memory usage #{Format.space(state.mem)} exceeds limit #{Format.space(spec.limitMem)} * #{spec.limitMemGrace}")
    end
    if spec.limitDisk && state.disk && state.disk > spec.limitDisk
      killCurrentJob("Current disk usage #{Format.space(state.disk)} exceeds limit #{Format.space(spec.limitDisk)}")
    end
    puts "Running job #{spec.handle} (pid #{@jobPid}): time #{Format.time(state.realTime)}, mem #{Format.space(state.mem)}, disk #{Format.space(state.disk)}"
  end

  def sendState(isLast); @sendStateMutex.synchronize {
    # isLast: whether it's the last time we're going to update the job
    puts "sendState(last=#{isLast})" if $verbose >= 3

    extractWorkerState
    extractJobState
    enforceLimits

    # Populate worker fields
    map = {}
    map['workerState'] = @state.toMap
    map['jobHandle'] = @job.spec.handle if @job
    map['jobState'] = @job.state.toMap if @job
    map['outPathContents'], newSentState = getOutPathContents(isLast) if @job

    #puts map.inspect
    response = makeCall("WorkerSetState", @state.handle, map)
    #puts response.inspect

    if response['success']
      @sentState = newSentState

      # Respond to any action
      action = response['action']
      if action
        case action
          when 'kill'
            killCurrentJob("Killed by server request")
          when 'update'
            @updateVersionInfo = response
          when 'clear'
            if not @job
              puts "Clearing #{@basePath}"
              system('rm', '-rf', @basePath)
              system('mkdir', '-p', @basePath)
            end
          else
            puts "ERROR: unknown action: #{action}"
        end
      end
    else
      puts "ERROR FROM SERVER (in setting worker status): #{response['message']}"
    end
  } end

  def updateVersion(map)
    puts "Updating from version #{$version}..."
    contents = decode(map['contents'])
    out = open($0, 'w')
    out.write(contents)
    out.close
    puts "Restarting: #{$restartCommand.join(" ")}"
    exec(*$restartCommand)
  end

  def runJob(jobSpec)
    puts "======= Running job #{jobSpec.handle}"
    @sendStateMutex.synchronize {
      @job = Job.new
      @job.spec = jobSpec
      @job.state = JobState.new
      @job.state.status = 'init'
      @job.state.workerHandle = @state.handle
      @job.state.startDate = Time.now.to_i
      @state.status = 'busy'
      @state.currJobHandle = @job.spec.handle
      @sentState = {} # file -> output bytes sent back thus far, modification time
    }

    # Download inPaths and setup environment
    actualBasePath = (@job.spec.shareWorkingPath ? '' : @basePath)
    actualWorkingPath = actualBasePath + @job.spec.workingPath
    system('mkdir', '-p', actualWorkingPath)
    if @job.spec.outPath
      actualOutPath = actualBasePath + @job.spec.outPath
      puts "Creating #{actualOutPath}"
      system('rm', '-rf', actualOutPath) if @job.spec.freshOutPath
      system('mkdir', '-p', actualOutPath)
    end

    needPaths = @job.spec.inVersionPaths.map { |version,path|
      actualPath = actualBasePath + path
      oldVersion = getVersion(actualPath)
      next if oldVersion == version
      puts "Need #{path} [#{oldVersion} #{version}]" #if $verbose >= 3
      system('mkdir', '-p', File.dirname(actualPath))
      path
    }.compact
    if needPaths.size > 0
      response = makeCall('WorkerFetchPaths', @state.handle, needPaths, File.expand_path(@basePath))
    end

    if response && (not response['success'])
      @job.state.status = 'failed'
      @job.state.reason = response['message']
    else
      # Run job
      puts "=== Executing command"
      @job.state.status = 'running'
      # HACK: //<absolute path> => <scratch path><absolute path>
      command = @job.spec.command.join(' ').gsub(/\/\/\//, File.expand_path(@basePath)+"/") # Note that absolute paths change
      puts command
      @jobPid = fork { exec("cd #{actualWorkingPath} && (#{command})") }
      Process.waitpid(@jobPid)
      exitCode = $?.exitstatus || -1
      puts "exitCode: #{exitCode}"
      @job.state.status = exitCode == 0 ? 'done' : 'failed'
      @job.state.exitCode = exitCode
    end

    sendState(true)

    puts "=== Done"
    @sendStateMutex.synchronize {
      @state.currJobHandle = nil
      @state.status = 'idle'
      @job = nil
      @jobPid = nil
      @sentState = nil
    }
  end

  def startMonitorThread
    @monitorThread = Thread.new {
      while not @done
        begin
          sendState(false)
        rescue Exception => e
          puts "ERROR IN MONITORING THREAD: #{e}"
          puts "#{e.message}\n#{e.backtrace.join("\n")}" #if $verbose >= 2
          @server = connectToMaster
        end
        sleep @sleepInterval + rand(2) # Randomize a little
      end
    }
  end

  def runJobsLoop
    sendState(false)
    while not @done
      didSomething = false
      begin
        updateVersion(@updateVersionInfo) if @updateVersionInfo

        # Contact master to get job
        map = makeCall("WorkerGetJob", @state.handle)
        if map['success']
          if map['jobSpec']
            jobSpec = JobSpec.new.fromMap(map['jobSpec'])
            runJob(jobSpec)
            didSomething = true
          end
        else
          puts "ERROR FROM SERVER (in getting a job): #{job['message']}"
        end
      rescue Exception => e
        puts "NASTY ERROR: #{e}"
        puts "#{e.message}\n#{e.backtrace.join("\n")}" if $verbose >= 2
        @job = nil
        @server = connectToMaster
      end
      sleep @sleepInterval unless didSomething
    end

    monitorThread.join
  end
end

############################################################

class Client
  def makeCall(*args)
    ensureNoNulls(args)
    response = @server.call(*args)
    puts response['message'] if response['message']
    exit 1 if not response['success']
    response
  end

  def initialize(args)
    addCmd, directCmd, numTimes, specPath, priority, time, mem, memGrace, disk, tags, workerHandle,
    listSpec, infoSpec, deleteSpec, killSpec, rerunSpec, saveState,
    workerState, startWorkers, runWorkers, termWorkers, clearWorkers, resetWorkers, shutdownMaster,
    availabilityZone, instanceType, imageId, showHeaders, showTabs, shareWorkingPath =
        extractArgs(:args => args, :spec => [
      ['add', [String], nil], # Command (if -, read from command-line, one per line)
      ['direct', [String], nil], # Directly run this command
      ['numTimes', Fixnum, 1],
      ['specPath', String, 'job.spec'], # Command
      ['priority', Fixnum, nil],
      ['time', String, nil],
      ['mem', String, nil],
      ['memGrace', Float, nil],
      ['disk', String, nil],
      ['tags', [String], []],
      ['workerHandle', String, nil],
      ['list', [String], nil],
      ['info', [String], nil],
      ['delete', [String], nil],
      ['kill', [String], nil],
      ['rerun', [String], nil],
      ['saveState', TrueClass],
      ['w', TrueClass],
      ['startWorkers', Fixnum, 0],
      ['runWorkers', [String], nil],
      ['termWorkers', [String], []],
      ['clearWorkers', TrueClass],
      ['resetWorkers', [String], []],
      ['shutdownMaster', TrueClass],
      ['availabilityZone', String, nil],
      ['instanceType', String, nil],
      ['imageId', String, nil],
      ['headers', TrueClass],
      ['tabs', TrueClass],
      ['shareWorkingPath', TrueClass, false, 'Whether workers are on the same machine as the client and just run jobs in same directory'],
    nil])

    @server = connectToMaster

    processCmd = lambda { |cmd,direct|
      numTimes.times {
        jobSpec = JobSpec.new 
        jobSpec.fromMap(loadYaml(specPath)) if File.exists?(specPath)
        jobSpec.handle = newHandle('J')
        jobSpec.command = cmd
        jobSpec.workingPath = Dir.pwd
        jobSpec.limitTime = Format.parseTime(time) if time
        jobSpec.limitMem = Format.parseSpace(mem) if mem
        jobSpec.limitMemGrace = memGrace if memGrace
        jobSpec.limitDisk = Format.parseSpace(disk) if disk
        jobSpec.priority = priority if priority
        jobSpec.tags = tags if tags
        jobSpec.workerHandle = workerHandle if workerHandle
        jobSpec.shareWorkingPath = shareWorkingPath

        # Slightly hacky: try to figure out which files we need from the
        # command-line arguments (only need if not sharing resources)
        if not shareWorkingPath
          cmd.select { |arg|
            arg.split(/:/).each { |path|
              next unless File.exists?(path) && path !~ /^\//
              jobSpec.addInPath(path)
            }
          }
        end

        #puts jobSpec.toMap.inspect
        if $pretend
          job = Job.new
          job.spec = jobSpec
          printJob(job)
        elsif direct
          exec(*jobSpec.command)
        else
          makeCall('AddJob', jobSpec.toMap)
        end
      }
    }
    if addCmd
      if addCmd == ['-'] # Read commands from stdin
        while cmd = gets
          processCmd.call(cmd.split, false)
        end
      else
        processCmd.call(addCmd, false)
      end
    end
    if directCmd
      processCmd.call(directCmd, true)
    end

    makeCall('SaveState') if saveState

    if listSpec
      listSpec = ['all'] if listSpec.size == 0
      response = makeCall('OperateOnJobs', 'list', listSpec)
      renderTable(response['output'], showHeaders, showTabs).each { |line| puts line }
    end
    if infoSpec # Print out more information than just listing
      infoSpec = ['all'] if infoSpec.size == 0
      response = makeCall('OperateOnJobs', 'info', infoSpec)
      response['output'].each { |map| printJob(Job.new.fromMap(map)) }
    end
    makeCall('OperateOnJobs', 'delete', deleteSpec) if deleteSpec
    makeCall('OperateOnJobs', 'kill', killSpec) if killSpec
    makeCall('OperateOnJobs', 'rerun', rerunSpec) if rerunSpec

    if workerState
      response = makeCall('GetWorkerState')
      renderTable(response['output'], showHeaders, showTabs).each { |line| puts line }
    end
    response = makeCall('StartWorkers', startWorkers, availabilityZone || "", instanceType || "", imageId || "") if startWorkers > 0
    if runWorkers
      runWorkers = ['floating'] if runWorkers.size == 0
      response = makeCall('RunWorkers', runWorkers)
    end
    response = makeCall('TermWorkers', termWorkers) if termWorkers.size > 0
    response = makeCall('ResetWorkers', resetWorkers) if resetWorkers.size > 0
    response = makeCall('ClearWorkers') if clearWorkers

    makeCall('ShutdownMaster') if shutdownMaster
  end

  def printJob(job)
    handle = job.spec.handle
    date = Format.date(job.spec.creationDate)
    status = job.status + (job.state ? " on #{job.state.workerHandle}" : "")
    tags = job.spec.tags.join(',')
    command = job.spec.command.join(' ')
    puts "#{handle} : #{date} [#{status}] {#{tags}}: #{command}"
    if job.state
      puts "  Reason: #{job.state.reason}" if job.state.reason.size > 0
      puts "  time: #{Format.time(job.state.realTime)}, mem: #{Format.space(job.state.maxMem)}, disk: #{Format.space(job.state.maxDisk)}"
    end
    job.spec.inVersionPaths.each { |version,path|
      puts "  I: #{relPath(path)} [#{version}]"
    }
    job.spec.outModePaths.each { |mode,path|
      puts "  O: #{relPath(path)} [#{mode}]"
    }
  end
end

############################################################

$verbose, $pretend, mode, $masterHost, $masterPort = extractArgs(:recognizeAllOpts => false, :args => ARGV, :spec => [
  ['verbose', Fixnum, 0],
  ['pretend', TrueClass],
  ['mode', String, 'client'],
  ['masterHost', String, 'localhost'],
  ['masterPort', Fixnum, 7890],
nil])

case mode
  when 'master' then Master.new(ARGV)
  when 'worker' then Worker.new(ARGV)
  when 'client' then Client.new(ARGV)
  else raise "Unknown mode: #{mode}"
end
